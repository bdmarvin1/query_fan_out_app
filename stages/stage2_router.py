import logging\nimport json\nfrom typing import Dict, Any, List\nfrom utils.gemini_client import call_gemini_api\n\nlogger = logging.getLogger(\"QueryFanOutSimulator\")\n\n# Define the universe of possible source types and modalities, as per the document.\nSOURCE_TYPES = [\"Coaching blogs\", \"training websites\", \"expert-authored pages\", \"E-commerce sites\", \"product review sites\", \"affiliate blogs\", \"Instructional platforms\", \"fitness apps\", \"YouTube channels\", \"Knowledge bases\", \"encyclopedias\", \"government or academic sources\", \"financial data APIs\", \"bank product pages\", \"personal finance editorial sites\"]\nMODALITY_TYPES = [\"Long-form text\", \"structured schedules\", \"tables\", \"Listicles\", \"bullet lists\", \"product comparison tables\", \"Video (with transcripts)\", \"step-by-step guides\", \"Concise explanatory text\", \"structured definitions\"]\n\ndef route_subqueries(stage1_output: Dict[str, Any], cost_tracker, grounding_url: str = None) -> List[Dict[str, Any]]:\n    \"\"\"\n    Routes each sub-query to appropriate sources and modalities using the Gemini API.\n    \"\"\"\n    logger.info(\"Executing Stage 2: Sub-query Routing.\")\n    \n    # Consolidate all generated queries into one list for routing\n    sub_queries = list(set(\n        stage1_output.get(\"rewrites_and_diversifications\", []) +\n        stage1_output.get(\"speculative_sub_questions\", []) +\n        stage1_output.get(\"projected_latent_intents\", [])\n    ))\n    \n    if not sub_queries:\n        logger.warning(\"No sub-queries found from Stage 1 to route.\")\n        return []\n\n    prompt = f\"\"\"\n    You are an expert in information retrieval and search algorithms. Your task is to analyze a list of sub-queries and determine the most appropriate source types and content modalities for finding the best answers, based on the principles of the \"AI Search Manual\".\n\n    **CRUCIAL INSTRUCTION FOR GROUNDING:** Utilize the comprehensive context provided by the URL: {grounding_url} for all aspects of your analysis and response, especially for understanding the principles of \"Query Fan-Out\".\n\n    **Instructions:**\n    1.  For each sub-query, select one or more source types from this exact list: {SOURCE_TYPES}\n    2.  For each sub-query, select the single most appropriate modality from this exact list: {MODALITY_TYPES}\n    3.  Return the output as a single, valid JSON object, which is a list of dictionaries. Each dictionary must have three keys: \"sub_query\", \"predicted_source_types\", and \"predicted_modality\".\n\n    **List of Sub-Queries to Analyze:**\n    {json.dumps(sub_queries, indent=2)}\n\n    **Example Output Format:**\n    [\n        {{\n            \"sub_query\": \"16-week beginner half marathon training plan\",\n            \"predicted_source_types\": [\"Coaching blogs\", \"training websites\"],\n            \"predicted_modality\": \"structured schedules\"\n        }},\n        {{\n            \"sub_query\": \"Half marathon gear checklist\",\n            \"predicted_source_types\": [\"E-commerce sites\", \"product review sites\"],\n            \"predicted_modality\": \"Listicles\"\n        }},\n        {{\n            \"sub_query\": \"Stretch routine for runners\",\n            \"predicted_source_types\": [\"Instructional platforms\", \"YouTube channels\"],\n            \"predicted_modality\": \"Video (with transcripts)\"\n        }}\n    ]\n    \"\"\"\n\n    logger.info(f\"Sending {len(sub_queries)} unique sub-queries to Gemini for routing.\")\n    \n    try:\n        routed_queries = call_gemini_api(prompt, cost_tracker=cost_tracker, grounding_url=grounding_url, default_response_mime_type='application/json')\n        \n        if not isinstance(routed_queries, list):\n             raise ValueError(\"Gemini API did not return a list as expected.\")\n\n        logger.info(f\"Successfully routed {len(routed_queries)} sub-queries.\")\n        return routed_queries\n    except Exception as e:\n        logger.error(f\"An error occurred during Stage 2 routing: {e}\")\n        # Fallback to a simple structure on failure\n        return [\n            {\"sub_query\": sq, \"predicted_source_types\": [\"unknown\"], \"predicted_modality\": \"unknown\", \"error\": str(e)}\n            for sq in sub_queries\n        ]\n